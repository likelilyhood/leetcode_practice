对于hash table 而言，出现的场景大多在于要求时间精度和比对的场景中，往往可以使用暴力手段进行直接求解，但是hash table 的出向解决了这个问题，在牺牲了一定空间后，我们可以获得时间复杂度仅仅为O(1)的操作函数
关于hash 数的生成不做过多赘述，进一步需要关注的问题是在于如何使用hash表进行实现，其次还有在调用官方stl时，应该注意的底层知识
hash表的几种实现方法和要点注意
1. array
2. set 
3. map

##### 集合相关表格
| 集合           | 底层实现 | 是否有序 | 数值能否重复 | 数值能否更改 | 查询效率 | 增删效率 |
| :------------- | :------- | :------- | :--------------- | :----------------- | :------- | :------- |
| `std::set`     | 红黑树   | 有序     | 否               | 否                 | O(log n) | O(log n) |
| `std::multiset` | 红黑树   | 有序     | 是               | 否                 | O(log n) | O(log n) |
| `std::unordered_set` | 哈希表   | 无序     | 否               | 否                 | O(1)     | O(1)     |

在这个表格中可以看到，unordered_set底层实现是hash表，而set 和multiset底层确实红黑树，一种平衡二叉搜索树，也就是对应的索引值不可以进行修改
##### 映射相关表格
| 映射           | 底层实现 | 是否有序 | 数值能否重复 | 数值能否更改 | 查询效率 | 增删效率 |
| :------------- | :------- | :------- | :--------------- | :----------------- | :------- | :------- |
| `std::map`     | 红黑树   | KEY 有序 | key 不可重复     | key 不可修改       | O(log n) | O(log n) |
| `std::multimap` | 红黑树   | KEY 有序 | key 可重复       | key 不可修改       | O(log n) | O(log n) |
| `std::unordered_map` | 哈希表   | Key 无序 | key 不可重复     | key 不可修改       | O(1)     | O(1)     |

同样的 这个映射的表格里，sd::map和std::multimap的底层依旧是红黑树，保持着有序

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。
### 总结
总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。

但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法
